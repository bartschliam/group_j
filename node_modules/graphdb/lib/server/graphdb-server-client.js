"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ServerClient = require('./server-client');

var LoggingUtils = require('../logging/logging-utils');

var MediaType = require('../http/media-type');

var HttpRequestBuilder = require('../http/http-request-builder');

var REPOSITORY_SERVICE_URL = '/rest/repositories';
var SECURITY_SERVICE_URL = '/rest/security';
/**
 * Implementation of the graphDB server operations.
 *
 *  Used to automate the security user management API:
 *  add, edit, or remove users.  Also used to add, edit,
 *  or remove a repository to/from any attached location.
 *  You can work with multiple remote locations from a
 *  single access point.
 *
 *  @class
 *  @author Teodossi Dossev
 *
 */

var GraphDBServerClient = /*#__PURE__*/function (_ServerClient) {
  _inherits(GraphDBServerClient, _ServerClient);

  var _super = _createSuper(GraphDBServerClient);

  /**
   * @param {ServerClientConfig} config for the server client.
   **/
  function GraphDBServerClient(config) {
    _classCallCheck(this, GraphDBServerClient);

    return _super.call(this, config);
  }
  /**
   * Get the default repository configuration for the repository type
   *
   * @param {RepositoryType|String} repositoryType the type for which a
   * default configuration is required
   * @return {Promise<HttpResponse|Error>} a promise which resolves to response
   * wrapper or rejects with error if thrown during execution.
   */


  _createClass(GraphDBServerClient, [{
    key: "getDefaultConfig",
    value: function getDefaultConfig(repositoryType) {
      if (!repositoryType) {
        throw new Error('Repository type is required parameter!');
      }

      var requestBuilder = HttpRequestBuilder.httpGet("".concat(REPOSITORY_SERVICE_URL, "/defaultConfig/").concat(repositoryType)).addAcceptHeader(MediaType.APPLICATION_JSON);
      return this.execute(requestBuilder);
    }
    /**
     * Get the repository configuration
     *
     * @param {string} repositoryId the repository id
     * @param {string} [location] optional repository location
     * @return {Promise<HttpResponse|string|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "getRepositoryConfig",
    value: function getRepositoryConfig(repositoryId, location) {
      if (!repositoryId) {
        throw new Error('Repository id is required parameter!');
      }

      var repositoryLocation = location ? "?location=".concat(location) : '';
      var requestBuilder = HttpRequestBuilder.httpGet("".concat(REPOSITORY_SERVICE_URL, "/").concat(repositoryId).concat(repositoryLocation)).addContentTypeHeader(MediaType.APPLICATION_JSON);
      return this.execute(requestBuilder);
    }
    /**
     * Download the repository configuration in turtle format
     * @param {string} repositoryId the repository id
     * @param {string} [location] optional repository location
     * @return {Promise<string | any>} a service request that will resolve to a
     * readable stream to which the client can subscribe and consume the emitted
     * strings as soon as they are available. Resolves to turtle format.
     */

  }, {
    key: "downloadRepositoryConfig",
    value: function downloadRepositoryConfig(repositoryId, location) {
      var _this = this;

      var requestBuilder = HttpRequestBuilder.httpGet("".concat(REPOSITORY_SERVICE_URL, "/").concat(repositoryId, "/download")).addContentTypeHeader(MediaType.TEXT_TURTLE).setResponseType('stream');
      return this.execute(requestBuilder).then(function (response) {
        _this.logger.debug(LoggingUtils.getLogPayload(response, requestBuilder.getParams()), 'Downloaded data');

        return response.getData();
      });
    }
    /**
     * Create repository according to the provided configuration
     * @param {RepositoryConfig} repositoryConfig
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "createRepository",
    value: function createRepository(repositoryConfig) {
      var requestBuilder = HttpRequestBuilder.httpPut("".concat(REPOSITORY_SERVICE_URL, "/").concat(repositoryConfig.id)).setData(this.objectToJson(repositoryConfig)).addContentTypeHeader(MediaType.APPLICATION_JSON).addAcceptHeader(MediaType.TEXT_PLAIN);
      return this.execute(requestBuilder);
    }
    /**
     * Delete repository with the provided id.
     * @override
     * @param {string} id of the repository which should be deleted.
     * @return {Promise<any>} promise which resolves with the delete result.
     */

  }, {
    key: "deleteRepository",
    value: function deleteRepository(id) {
      var _this2 = this;

      if (!id) {
        throw new Error('Repository id is required parameter!');
      }

      var requestBuilder = HttpRequestBuilder.httpDelete("".concat(REPOSITORY_SERVICE_URL, "/").concat(id));
      return this.execute(requestBuilder).then(function (response) {
        _this2.logger.info(LoggingUtils.getLogPayload(response, {
          repoId: id
        }), 'Deleted repository');
      });
    }
    /**
     * Checks if GraphDB security is enabled.
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "isSecurityEnabled",
    value: function isSecurityEnabled() {
      var requestBuilder = HttpRequestBuilder.httpGet(SECURITY_SERVICE_URL).addAcceptHeader(MediaType.APPLICATION_JSON);
      return this.execute(requestBuilder);
    }
    /**
     * Enable or disable GraphDB security.
     * @param {boolean} enabled <code>true</code> if security is enabled and
     * <code>false</code> otherwise.
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "toggleSecurity",
    value: function toggleSecurity(enabled) {
      var requestBuilder = HttpRequestBuilder.httpPost("".concat(SECURITY_SERVICE_URL, "?useSecurity=").concat(enabled)).addContentTypeHeader(MediaType.APPLICATION_JSON).setData("".concat(enabled));
      return this.execute(requestBuilder);
    }
    /**
     * Enable or disable access to a predefined set of functionalities
     * without having to log in.
     * To use free access, you must have security enabled.
     * Use with extreme caution, as the changes that are made to the
     * application settings may possibly change the behavior of the
     * GraphDB Workbench for the logged-in user or for all users
     * if logged in as admin.
     * @param {boolean} enabled <code>true</code> if free access is enabled and
     * <code>false</code> otherwise.
     * @param {string[]} authorities Array of read and/or write access rights
     * described in the following template:
     * <code>READ_REPO_{repository ID}</code> to grant repository read rights
     * <code>WRITE_REPO_{repository ID}</code> to grant repository write rights
     * @param {AppSettings} appSettings configure the default behavior
     * of the GraphDB Workbench
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "updateFreeAccess",
    value: function updateFreeAccess(enabled, authorities, appSettings) {
      var requestBuilder = HttpRequestBuilder.httpPost("".concat(SECURITY_SERVICE_URL, "/freeaccess")).addContentTypeHeader(MediaType.APPLICATION_JSON).addAcceptHeader(MediaType.TEXT_PLAIN).setData({
        appSettings: this.objectToJson(appSettings),
        authorities: authorities,
        enabled: enabled
      });
      return this.execute(requestBuilder);
    }
    /**
     * Check if free access is enabled
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "getFreeAccess",
    value: function getFreeAccess() {
      var requestBuilder = HttpRequestBuilder.httpGet("".concat(SECURITY_SERVICE_URL, "/freeaccess")).addContentTypeHeader(MediaType.APPLICATION_JSON);
      return this.execute(requestBuilder);
    }
    /**
     * Create a user
     * @param {string} username User name
     * @param {string} password User password
     * @param {string[]} [grantedAuthorities] Array of read and/or write access
     * rights described in the following template:
     * <code>READ_REPO_{repository ID}</code> to grant repository read rights
     * <code>WRITE_REPO_{repository ID}</code> to grant repository write rights
     * @param {AppSettings} [appSettings] configure the default behavior
     * of the GraphDB Workbench
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "createUser",
    value: function createUser(username, password, grantedAuthorities, appSettings) {
      var requestBuilder = HttpRequestBuilder.httpPost("".concat(SECURITY_SERVICE_URL, "/user/").concat(username)).addContentTypeHeader(MediaType.APPLICATION_JSON).addAcceptHeader(MediaType.TEXT_PLAIN).setData({
        username: username,
        password: password,
        grantedAuthorities: grantedAuthorities,
        appSettings: this.objectToJson(appSettings)
      });
      return this.execute(requestBuilder);
    }
    /**
     * Edit user.
     * Use with extreme caution, as the changes that are made to the
     * application settings may possibly change the behavior of the
     * GraphDB Workbench for the user.
     * @param {string} username User name
     * @param {string} [password] User password
     * @param {string[]} [grantedAuthorities] Array of read and/or write access
     * rights described in the following template:
     * <code>READ_REPO_{repository ID}</code> to grant repository read rights
     * <code>WRITE_REPO_{repository ID}</code> to grant repository write rights
     * @param {AppSettings} [appSettings] configure the default behavior
     * of the GraphDB Workbench
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "updateUser",
    value: function updateUser(username, password, grantedAuthorities, appSettings) {
      var requestBuilder = HttpRequestBuilder.httpPut("".concat(SECURITY_SERVICE_URL, "/user/").concat(username)).addContentTypeHeader(MediaType.APPLICATION_JSON).addAcceptHeader(MediaType.TEXT_PLAIN).setData({
        username: username,
        password: password,
        grantedAuthorities: grantedAuthorities,
        appSettings: this.objectToJson(appSettings)
      });
      return this.execute(requestBuilder);
    }
    /**
     * Change setting for a logged user.
     * Use with extreme caution, as the changes that are made to the
     * application settings may possibly change the behavior of the
     * GraphDB Workbench for the user.
     * @param {string} username User name
     * @param {string} [password] User password
     * @param {AppSettings} [appSettings] configure the default behavior
     * of the GraphDB Workbench
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "updateUserData",
    value: function updateUserData(username, password, appSettings) {
      var requestBuilder = HttpRequestBuilder.httpPatch("".concat(SECURITY_SERVICE_URL, "/user/").concat(username)).addContentTypeHeader(MediaType.APPLICATION_JSON).addAcceptHeader(MediaType.TEXT_PLAIN).setData({
        username: username,
        password: password,
        appSettings: this.objectToJson(appSettings)
      });
      return this.execute(requestBuilder);
    }
    /**
     * Get a user
     * @param {string} username User name
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "getUser",
    value: function getUser(username) {
      var requestBuilder = HttpRequestBuilder.httpGet("".concat(SECURITY_SERVICE_URL, "/user/").concat(username)).addContentTypeHeader(MediaType.APPLICATION_JSON);
      return this.execute(requestBuilder);
    }
    /**
     * Deletes a user
     * @param {string} username User name
     * @return {Promise<HttpResponse|Error>} a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "deleteUser",
    value: function deleteUser(username) {
      var requestBuilder = HttpRequestBuilder.httpDelete("".concat(SECURITY_SERVICE_URL, "/user/").concat(username)).addAcceptHeader(MediaType.TEXT_PLAIN);
      return this.execute(requestBuilder);
    }
    /**
     * @private
     * @param {Object} object to get json from
     * @return {string | {}} json representation of object
     * or empty object if undefined
     */

  }, {
    key: "objectToJson",
    value: function objectToJson(object) {
      return object && object.toJson() || {};
    }
  }]);

  return GraphDBServerClient;
}(ServerClient);

module.exports = GraphDBServerClient;