"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var HttpClient = require('../http/http-client');

var HttpResponse = require('../http/http-response');

var ConsoleLogger = require('../logging/console-logger');

var LoggingUtils = require('../logging/logging-utils');

var RDFRepositoryClient = require('../repository/rdf-repository-client');

var RepositoryClientConfig = require('../repository/repository-client-config');

var HttpRequestBuilder = require('../http/http-request-builder');

var AuthenticationService = require('../service/authentication-service');

var RDFMimeType = require('../http/rdf-mime-type');

var SERVICE_URL = '/repositories';
/**
 * Implementation of the server operations.
 *
 * If the server against which this client will be used has security enabled,
 * then it should be configured with the username and password in the
 * {@link ServerClientConfig}. In this case a login attempt is made before any
 * API method to be executed. Upon successful login an {@link User} which holds
 * the credentials and the authorization token in the context of the client is
 * created. In all consecutive API calls the authorization token is sent as a
 * http header.
 *
 * By default {@link ServerClientConfig} is configured with
 * <code>keepAlive = true</code> which means that upon authorization token
 * expiration current logged in user would be re-logged automatically before
 * next API call. This configuration can be changed within the configuration.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */

var ServerClient = /*#__PURE__*/function () {
  /**
   * @param {ServerClientConfig} config for the server client.
   **/
  function ServerClient(config) {
    _classCallCheck(this, ServerClient);

    this.config = config;
    this.initHttpClient();
    this.initLogger();
    this.authenticationService = new AuthenticationService(this.httpClient);
  }
  /**
   * Get an array of repository ids available in the server.
   *
   * @return {Promise<Array>} promise which resolves with an Array with
   * repository ids.
   */


  _createClass(ServerClient, [{
    key: "getRepositoryIDs",
    value: function getRepositoryIDs() {
      var _this = this;

      var requestBuilder = HttpRequestBuilder.httpGet(SERVICE_URL).addAcceptHeader(RDFMimeType.SPARQL_RESULTS_JSON);
      return this.execute(requestBuilder).then(function (response) {
        _this.logger.debug(LoggingUtils.getLogPayload(response, {}), 'Fetched repositories');

        return response.getData().results.bindings.map(function (_ref) {
          var id = _ref.id;
          return id.value;
        });
      });
    }
    /**
     * Check if repository with the provided id exists.
     * @param {string} id of the repository which should be checked.
     * @return {Promise<boolean>} promise which resolves with boolean value.
     */

  }, {
    key: "hasRepository",
    value: function hasRepository(id) {
      if (!id) {
        throw new Error('Repository id is required parameter!');
      }

      return this.getRepositoryIDs().then(function (repositoryIds) {
        return repositoryIds.indexOf(id) !== -1;
      });
    }
    /**
     * Creates a repository client instance with the provided id and
     * configuration.
     * @param {string} id of the repository
     * @param {RepositoryClientConfig} config for the overridable repository
     *    configuration.
     * @return {Promise<RDFRepositoryClient>} promise which resolves with
     *    new RDFRepositoryClient instance.
     */

  }, {
    key: "getRepository",
    value: function getRepository(id, config) {
      var _this2 = this;

      if (!id) {
        throw new Error('Repository id is required parameter!');
      }

      if (!config || !(config instanceof RepositoryClientConfig)) {
        throw new Error('RepositoryClientConfig is required parameter!');
      }

      return this.hasRepository(id).then(function (exists) {
        if (exists) {
          return new RDFRepositoryClient(config);
        }

        _this2.logger.error({
          repoId: id
        }, 'Repository does not exist');

        return Promise.reject(new Error("Repository with id ".concat(id, " does not exists.")));
      });
    }
    /**
     * Delete repository with the provided id.
     * @param {string} id of the repository which should be deleted.
     * @return {Promise<any>} promise which resolves with the delete result.
     */

  }, {
    key: "deleteRepository",
    value: function deleteRepository(id) {
      var _this3 = this;

      if (!id) {
        throw new Error('Repository id is required parameter!');
      }

      var requestBuilder = HttpRequestBuilder.httpDelete("".concat(SERVICE_URL, "/").concat(id));
      return this.execute(requestBuilder).then(function (response) {
        _this3.logger.info(LoggingUtils.getLogPayload(response, {
          repoId: id
        }), 'Deleted repository');
      });
    }
    /**
     * Initializes the http client.
     */

  }, {
    key: "initHttpClient",
    value: function initHttpClient() {
      this.httpClient = new HttpClient(this.config.getEndpoint()).setDefaultReadTimeout(this.config.getTimeout()).setDefaultWriteTimeout(this.config.getTimeout());
    }
    /**
     * Initializes the logger.
     */

  }, {
    key: "initLogger",
    value: function initLogger() {
      this.logger = new ConsoleLogger({
        name: 'ServerClient',
        serverURL: this.config.getEndpoint()
      });
    }
    /**
     * Executes http request wrapped in provided request builder.
     * If the server config provides username and password, then a logging attempt
     * is made. Upon successful login the auth data is stored for later requests.
     *
     * @public
     *
     * @param {HttpRequestBuilder} requestBuilder
     *
     * @return {Promise<HttpResponse|Error>} a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "execute",
    value: function execute(requestBuilder) {
      var _this4 = this;

      var startTime = Date.now();
      return this.authenticationService.login(this.config, this.getLoggedUser()).then(function (user) {
        _this4.setLoggedUser(user);

        _this4.decorateRequestConfig(requestBuilder);

        return _this4.httpClient.request(requestBuilder);
      }).then(function (response) {
        var executionResponse = new HttpResponse(response, _this4.httpClient);
        executionResponse.setElapsedTime(Date.now() - startTime);
        return executionResponse;
      })["catch"](function (error) {
        var status = error.response ? error.response.status : null; // Unauthorized

        if (status && status === 401 && _this4.config.getKeepAlive()) {
          // re-execute will try to re-login the user and update it
          return _this4.execute(requestBuilder);
        }

        return Promise.reject(error);
      });
    }
    /**
     * Performs a logout of logged in user.
     *
     * This method normally shouldn't be called as it does nothing but just clears
     * current authentication token. After that any consecutive API call against
     * the secured server will throw <code>Unauthorized</code> error with status
     * code <code>401</code> because the token is not sent any more, which in
     * result will force re-login for the same user to be executed by default,
     * unless the client is configured with
     * <code>ServerClientConfig.keepAlive = false</code>
     *
     * @private
     *
     * @return {Promise} returns a promise which resolves with undefined.
     */

  }, {
    key: "logout",
    value: function logout() {
      return this.authenticationService.logout(this.getLoggedUser());
    }
    /**
     * Allow request config to be altered before sending.
     *
     * @private
     * @param {HttpRequestBuilder} requestBuilder
     */

  }, {
    key: "decorateRequestConfig",
    value: function decorateRequestConfig(requestBuilder) {
      var token = this.authenticationService.getAuthenticationToken(this.getLoggedUser());

      if (token) {
        requestBuilder.addAuthorizationHeader(token);
      }
    }
    /**
     * Logged user getter.
     * @return {User} user
     */

  }, {
    key: "getLoggedUser",
    value: function getLoggedUser() {
      return this.user;
    }
    /**
     * User setter
     * @param {User} user
     *
     * @return {ServerClient}
     */

  }, {
    key: "setLoggedUser",
    value: function setLoggedUser(user) {
      this.user = user;
      return this;
    }
  }]);

  return ServerClient;
}();

module.exports = ServerClient;